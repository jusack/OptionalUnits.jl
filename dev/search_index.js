var documenterSearchIndex = {"docs":
[{"location":"todo/#Open-Points","page":"Open Issues","title":"Open Points","text":"","category":"section"},{"location":"todo/","page":"Open Issues","title":"Open Issues","text":"Right now it is not possible to use Complex numbers without units, since the created method dispatches on Real instead of Number, this was done, because Unitful.Quantity is also a subtype of Number and therefore the method could be called with a quantity of the wrong dimension. It would be possible to add another check for each variable, but for now the numerical values are restricted to Real.\nDuring the creating of the default constructor for a struct, the complete struct definition is evaluated in the scope of the macro to extract the fieldnames. I am not sure about the consequences this might have, so there might be a better way to extract the fieldnames from the Expr\nCurrently the @optionalunits macro only works with the function f(x) end syntax, the shorthand form f(x)= is not yet supported!","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptionalUnits","category":"page"},{"location":"#OptionalUnits","page":"Home","title":"OptionalUnits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Having the appropiate physical units attached to your variables is a good way to protect yourself from accidental miscalculations and keeps you from wondering if that float is supposed to be in m or mm. However when using Unitful I reached a point, where I either had to use units in all of my code (which is not something that I want to be forced to do) or I found myself writing wrapper functions that added an implicit unit to the raw number and passed it to the function using Unitful. To automate this process I created this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package defines the @optionalunits macro that can be attached to a function or struct definition to automatically define a function or constructor that can either use a Unitful.Quantity of the right dimension or use a raw number with an implicit unit allowing the user of the function to choose either the error detection mechanism of Unitfuls explicit units or the simplicity of raw numbers with implicit units.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nCurrently the @optionalunits macro only works with the function f(x) end syntax, the shorthand form f(x)= is not yet supported!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Applied to a function definition the @optionalunits macro can be used like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@optionalunits function addOneMeter(x::Unitful.Length→u\"m\")\n    return x+1u\"m\"\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Behind every type parameter that is a Unitful.Dimension a default unit can be annotated with → (\\rightarrow[TAB]]). The macro changes the function definition to the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function addOneMeter(x::Union{Unitful.Length,Real})\n    if Unitful.dimension(x) == NoDims\n        @warn \"Used default unit m for\" x\n        x *= u\"m\"\n    end\n        \n    return x+1u\"m\"\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The macro also works with array-like types of uniform dimension","category":"page"},{"location":"","page":"Home","title":"Home","text":"@optionalunits function addOneMeter(x::Vector{Unitful.Length→u\"m\"})\n    return x.+1u\"m\"\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"the new function definition looks slightly different:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function addOneMeter(x::Union{Vector{<:Unitful.Length},Vector{<:Real}})\n    dims = Unitful.dimension(x)\n    @assert all(dims .== [first(dims)]) \"The array-like type x has mixed dimensions which is not supported by @optionalunits\"\n    if first(dims) == NoDims\n        @warn \"Used default unit m for array-like type\" x\n        x *= u\"m\"\n    end\n        \n    return x.+1u\"m\"\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This definition allows the function to be called with or without units:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> addOneMeter(1u\"m\")\n2 m\n\njulia> addOneMeter(1.0u\"mm\")\n1.001 m\n\njulia> addOneMeter(1.0)\n┌ Warning: Used default unit m for\n│   x = 1.0\n└ @ Main REPL[18]:3\n2.0 m\n\njulia> addOneMeter(1.0u\"m/s\")\nERROR: MethodError: no method matching addOneMeter(::Quantity{Float64, 𝐋  𝐓 ^-1, Unitful.FreeUnits{(m, s^-1), 𝐋  𝐓 ^-1, nothing}})","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course multiple annotated and unannotated arguments, the combination of these two versions, and the use of optional arguments works.","category":"page"},{"location":"#Structs","page":"Home","title":"Structs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use units in a struct Unitful recommends using a concrete type for every field, i.e. a Unitful.Quantity with a fixed datatype, dimension and unit. Therefore, no extra annotation of default units is needed to use the @optionalunits macro. When applied on a struct definition the macro redefines the default outer constructor (with all Any parameters) and adds the fallback to use the default units:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@optionalunits struct Point\n    x::typeof(1.0u\"m\")\n    y::typeof(1.0u\"m\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The struct definition itself is not changed, but the following outer constructor is defined:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function Point(x,y)\n    if dimension(x) == NoDims\n        @warn \"Used default unit m for \" x\n        x *= u\"m\"\n    end\n    x = Base.convert(Core.fieldtype(Point, 1), x)\n\n    if dimension(y) == NoDims\n        @warn \"Used default unit m for \" y\n        y *= u\"m\"\n    end\n    y = Base.convert(Core.fieldtype(Point, 2), y)\n\n    return Point(x,y)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same principle applies to fields of an array-like type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code can be found on GitHub.","category":"page"},{"location":"#Exports","page":"Home","title":"Exports","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [OptionalUnits]","category":"page"},{"location":"#OptionalUnits.@optionalunits-Tuple{Any}","page":"Home","title":"OptionalUnits.@optionalunits","text":"Can be applied to function and struct definitions that use Unitful types to add default units, when the parameters that are passed to the function do not have a unit attached.\n\nIn a function definition the type parameter e.g. Unitful.Length is appended with the default unit (e.g. x::Unitful.Length→u\"mm\")\n\nIn a struct definition nothing additional has to be added, the field types with Unitful.Quantity will be detected\n\nExamples\n\njulia> using OptionalUnits, Unitful\n\njulia>  @optionalunits function addOneMeter(x::Unitful.Length→u\"m\")\n            return x+1u\"m\"\n        end\n\njulia>  @optionalunits function addOneMeter(x::Vector{Unitful.Length→u\"m\"})\n            return x.+1u\"m\"\n        end\n\njulia> @optionalunits struct Point\n            x::typeof(1.0u\"m\")\n            y::typeof(1.0u\"m\")\n        end\n\njulia>  Point(1,2)\n\n\n\n\n\n","category":"macro"}]
}
